stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
}
# Model 1: Using all explanatory variables
model1 <- glm(G1 ~ ., data = students.math, family = poisson())
summary(model1)
# Calculate Pearson residuals
pearson.residuals <- residuals(model1, type = "pearson")
# Calculate Anscombe residuals
anscombe.residuals <- residuals(model1, type = "response")^(1/3)
# Plot Pearson residuals
plot.residuals(pearson.residuals, "Pearson Residuals")
# Plot Anscombe residuals
plot.residuals(anscombe.residuals, "Anscombe Residuals")
# Shapiro-Wilk test for normality of residuals
shapiro.test(pearson.residuals)
shapiro.test(anscombe.residuals)
# Residuals vs Fitted values plot
ggplot(data.frame(fitted = fitted(model1), residuals = pearson.residuals),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", col = "red") +
labs(title = "Residuals vs Fitted Values",
x = "Fitted Values",
y = "Pearson Residuals")
# Model 2: GLM with reduced covariates
model2 <- glm(G1 ~ sex + Fedu + studytime + failures + schoolsup + famsup + goout,
data = students.math,
family = poisson())
summary(model2)
# Analysis of deviance test between Model 1 and Model 2
deviance.analysis <- anova(model1, model2, test = "Chi")
print(deviance.analysis)
# Model 3: GLM with Walc instead of goout
model3 <- glm(G1 ~ sex + Fedu + studytime + failures + schoolsup + famsup + Walc,
data = students.math,
family = poisson())
summary(model3)
# Goodness-of-fit: AIC value
cat("AIC value of Model 3:", AIC(model3), "\n")
# Load necessary libraries
library(ggplot2)
library(readr)
# Function to create histogram and Q-Q plot
plot.distribution <- function(data, data.name) {
hist.plot <- ggplot(data.frame(data), aes(x = data)) +
geom_histogram(aes(y = after_stat(density)),
binwidth = 1,
fill = "white",
color = "black") +
stat_function(fun = dnorm,
args = c(mean = mean(data), sd = sd(data)),
color = "red") +
labs(title = paste("Histogram of", data.name),
x = data.name,
y = "Density")
qq.plot <- ggplot(data.frame(data), aes(sample = data)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", data.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
}
# Poisson distribution check
# Compare mean and variance for Poisson assumption
mean.var.disp <- function(variable, variable.name) {
cat("Mean, variance, and dispersion for", variable.name, "\n")
cat("Mean:", mean(variable), "\n")
cat("Variance:", var(variable), "\n")
# Check for overdispersion
fit <- glm(variable ~ 1, family = poisson)
dispersion <- sum(residuals(fit, type = "pearson")^2) / fit$df.residual
cat(paste("Dispersion:", dispersion, "\n\n"))
}
# Plot distributions for G1, G2, and G3
plot.distribution(students.math$G1, "G1")
plot.distribution(students.math$G2, "G2")
plot.distribution(students.math$G3, "G3")
# Statistical tests for normality
shapiro.test(students.math$G1)
shapiro.test(students.math$G2)
shapiro.test(students.math$G3)
# Poisson
mean.var.disp(students.math$G1, "G1")
mean.var.disp(students.math$G2, "G2")
mean.var.disp(students.math$G3, "G3")
# Function to create histogram and Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name) {
hist.plot <- ggplot(data.frame(residuals), aes(x = residuals)) +
geom_histogram(aes(y = after_stat(density)),
binwidth = 1,
fill = "white",
color = "black") +
stat_function(fun = dnorm,
args = c(mean = mean(residuals), sd = sd(residuals)),
color = "red") +
labs(title = paste("Histogram of", residual.name),
x = residual.name,
y = "Density")
qq.plot <- ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
}
# Model 1: Using all explanatory variables
model1 <- glm(G1 ~ ., data = students.math, family = poisson())
summary(model1)
# Calculate Pearson residuals
pearson.residuals <- residuals(model1, type = "pearson")
# Calculate Anscombe residuals
anscombe.residuals <- residuals(model1, type = "response")^(1/3)
# Plot Pearson residuals
plot.residuals(pearson.residuals, "Pearson Residuals")
# Plot Anscombe residuals
plot.residuals(anscombe.residuals, "Anscombe Residuals")
# Shapiro-Wilk test for normality of residuals
shapiro.test(pearson.residuals)
shapiro.test(anscombe.residuals)
# Residuals vs Fitted values plot
ggplot(data.frame(fitted = fitted(model1), residuals = pearson.residuals),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", col = "red") +
labs(title = "Residuals vs Fitted Values",
x = "Fitted Values",
y = "Pearson Residuals")
# Function to create histogram and Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name) {
hist.plot <- ggplot(data.frame(residuals), aes(x = residuals)) +
geom_histogram(aes(y = after_stat(density)),
binwidth = 1,
fill = "white",
color = "black") +
stat_function(fun = dnorm,
args = c(mean = mean(residuals), sd = sd(residuals)),
color = "red") +
labs(title = paste("Histogram of", residual.name),
x = residual.name,
y = "Density")
qq.plot <- ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
}
# Model 1: Using all explanatory variables
model1 <- glm(G1 ~ ., data = students.math, family = poisson())
summary(model1)
# Calculate Pearson residuals
pearson.residuals <- residuals(model1, type = "pearson")
# Calculate Anscombe residuals
anscombe.residuals <- residuals(model1, type = "response")^(1/3)
# Plot Pearson residuals
plot.residuals(pearson.residuals, "Pearson Residuals")
students.math <- read.csv("student-mat.csv", sep = ",")
head(students.math)
# Load necessary libraries
library(ggplot2)
library(readr)
# Function to create histogram and Q-Q plot
plot.distribution <- function(data, data.name) {
hist.plot <- ggplot(data.frame(data), aes(x = data)) +
geom_histogram(aes(y = after_stat(density)),
binwidth = 1,
fill = "white",
color = "black") +
stat_function(fun = dnorm,
args = c(mean = mean(data), sd = sd(data)),
color = "red") +
labs(title = paste("Histogram of", data.name),
x = data.name,
y = "Density")
qq.plot <- ggplot(data.frame(data), aes(sample = data)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", data.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
}
# Poisson distribution check
# Compare mean and variance for Poisson assumption
mean.var.disp <- function(variable, variable.name) {
cat("Mean, variance, and dispersion for", variable.name, "\n")
cat("Mean:", mean(variable), "\n")
cat("Variance:", var(variable), "\n")
# Check for overdispersion
fit <- glm(variable ~ 1, family = poisson)
dispersion <- sum(residuals(fit, type = "pearson")^2) / fit$df.residual
cat(paste("Dispersion:", dispersion, "\n\n"))
}
# Plot distributions for G1, G2, and G3
plot.distribution(students.math$G1, "G1")
plot.distribution(students.math$G2, "G2")
plot.distribution(students.math$G3, "G3")
# Statistical tests for normality
shapiro.test(students.math$G1)
shapiro.test(students.math$G2)
shapiro.test(students.math$G3)
# Poisson
mean.var.disp(students.math$G1, "G1")
mean.var.disp(students.math$G2, "G2")
mean.var.disp(students.math$G3, "G3")
# Function to create histogram and Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name) {
hist.plot <- ggplot(data.frame(residuals), aes(x = residuals)) +
geom_histogram(aes(y = after_stat(density)),
binwidth = 1,
fill = "white",
color = "black") +
stat_function(fun = dnorm,
args = c(mean = mean(residuals), sd = sd(residuals)),
color = "red") +
labs(title = paste("Histogram of", residual.name),
x = residual.name,
y = "Density")
qq.plot <- ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
}
# Model 1: Using all explanatory variables
model1 <- glm(G1 ~ ., data = students.math, family = poisson())
summary(model1)
# Calculate Pearson residuals
pearson.residuals <- residuals(model1, type = "pearson")
# Calculate Anscombe residuals
anscombe.residuals <- residuals(model1, type = "response")^(1/3)
# Plot Pearson residuals
plot.residuals(pearson.residuals, "Pearson Residuals")
# Plot Anscombe residuals
plot.residuals(anscombe.residuals, "Anscombe Residuals")
# Shapiro-Wilk test for normality of residuals
shapiro.test(pearson.residuals)
shapiro.test(anscombe.residuals)
# Residuals vs Fitted values plot
ggplot(data.frame(fitted = fitted(model1), residuals = pearson.residuals),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", col = "red") +
labs(title = "Residuals vs Fitted Values",
x = "Fitted Values",
y = "Pearson Residuals")
# Function to create histogram and Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name) {
hist.plot <- ggplot(data.frame(residuals), aes(x = residuals)) +
geom_histogram(aes(y = after_stat(density)),
binwidth = 1,
fill = "white",
color = "black") +
stat_function(fun = dnorm,
args = c(mean = mean(residuals), sd = sd(residuals)),
color = "red") +
labs(title = paste("Histogram of", residual.name),
x = residual.name,
y = "Density")
qq.plot <- ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
}
# Model 1: Using all explanatory variables
model1 <- glm(G1 ~ . - G2 - G3, data = students.math, family = poisson())
summary(model1)
# Calculate Pearson residuals
pearson.residuals <- residuals(model1, type = "pearson")
# Calculate Anscombe residuals
anscombe.residuals <- residuals(model1, type = "response")^(1/3)
# Plot Pearson residuals
plot.residuals(pearson.residuals, "Pearson Residuals")
# Plot Anscombe residuals
plot.residuals(anscombe.residuals, "Anscombe Residuals")
# Shapiro-Wilk test for normality of residuals
shapiro.test(pearson.residuals)
shapiro.test(anscombe.residuals)
# Residuals vs Fitted values plot
ggplot(data.frame(fitted = fitted(model1), residuals = pearson.residuals),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", col = "red") +
labs(title = "Residuals vs Fitted Values",
x = "Fitted Values",
y = "Pearson Residuals")
# Model 2: GLM with reduced covariates
model2 <- glm(G1 ~ sex + Fedu + studytime + failures + schoolsup + famsup + goout,
data = students.math,
family = poisson())
summary(model2)
# Analysis of deviance test between Model 1 and Model 2
deviance.analysis <- anova(model1, model2, test = "Chi")
print(deviance.analysis)
# Model 3: GLM with Walc instead of goout
model3 <- glm(G1 ~ sex + Fedu + studytime + failures + schoolsup + famsup + Walc,
data = students.math,
family = poisson())
summary(model3)
# Goodness-of-fit: AIC value
cat("AIC value of Model 3:", AIC(model3), "\n")
students.math <- read.csv("student-mat.csv", sep = ",")
head(students.math)
# Function to create histogram and Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name) {
hist.plot <- ggplot(data.frame(residuals), aes(x = residuals)) +
geom_histogram(aes(y = after_stat(density)),
binwidth = 1,
fill = "white",
color = "black") +
stat_function(fun = dnorm,
args = c(mean = mean(residuals), sd = sd(residuals)),
color = "red") +
labs(title = paste("Histogram of", residual.name),
x = residual.name,
y = "Density")
qq.plot <- ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
}
# Model 1: Using all explanatory variables
model1 <- glm(G1 ~ . - G2 - G3, data = students.math, family = poisson())
summary(model1)
# Calculate Pearson residuals
pearson.residuals <- residuals(model1, type = "pearson")
# Calculate Anscombe residuals
anscombe.residuals <- residuals(model1, type = "response")^(1/3)
# Plot Pearson residuals
plot.residuals(pearson.residuals, "Pearson Residuals")
# Plot Anscombe residuals
plot.residuals(anscombe.residuals, "Anscombe Residuals")
# Shapiro-Wilk test for normality of residuals
shapiro.test(pearson.residuals)
shapiro.test(anscombe.residuals)
# Residuals vs Fitted values plot
ggplot(data.frame(fitted = fitted(model1), residuals = pearson.residuals),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", col = "red") +
labs(title = "Residuals vs Fitted Values",
x = "Fitted Values",
y = "Pearson Residuals")
# Function to create a Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name)
qq.plot <- ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
gridExtra::grid.arrange(hist.plot, qq.plot)
# Function to create a Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name)
qq.plot <- ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
}
# Function to create ha Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name) {
qq.plot <- ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
}
# Model 1: Using all explanatory variables
model1 <- glm(G1 ~ . - G2 - G3, data = students.math, family = poisson())
summary(model1)
# Calculate Pearson residuals
pearson.residuals <- residuals(model1, type = "pearson")
# Calculate Anscombe residuals
anscombe.residuals <- residuals(model1, type = "response")^(1/3)
# Plot Pearson residuals
plot.residuals(pearson.residuals, "Pearson Residuals")
# Plot Anscombe residuals
plot.residuals(anscombe.residuals, "Anscombe Residuals")
# Shapiro-Wilk test for normality of residuals
shapiro.test(pearson.residuals)
shapiro.test(anscombe.residuals)
# Residuals vs Fitted values plot
ggplot(data.frame(fitted = fitted(model1), residuals = pearson.residuals),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", col = "red") +
labs(title = "Residuals vs Fitted Values",
x = "Fitted Values",
y = "Pearson Residuals")
# Function to create ha Q-Q plot for residuals
plot.residuals <- function(residuals, residual.name) {
ggplot(data.frame(residuals), aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
labs(title = paste("Q-Q Plot of", residual.name),
x = "Theoretical Quantiles",
y = "Sample Quantiles")
}
# Model 1: Using all explanatory variables
model1 <- glm(G1 ~ . - G2 - G3, data = students.math, family = poisson())
summary(model1)
# Calculate Pearson residuals
pearson.residuals <- residuals(model1, type = "pearson")
# Calculate Anscombe residuals
anscombe.residuals <- residuals(model1, type = "response")^(1/3)
# Plot Pearson residuals
plot.residuals(pearson.residuals, "Pearson Residuals")
# Plot Anscombe residuals
plot.residuals(anscombe.residuals, "Anscombe Residuals")
# Shapiro-Wilk test for normality of residuals
shapiro.test(pearson.residuals)
shapiro.test(anscombe.residuals)
# Residuals vs Fitted values plot
ggplot(data.frame(fitted = fitted(model1), residuals = pearson.residuals),
aes(x = fitted, y = residuals)) +
geom_point() +
geom_smooth(method = "loess", col = "red") +
labs(title = "Residuals vs Fitted Values",
x = "Fitted Values",
y = "Pearson Residuals")
# Model 2: GLM with reduced covariates
model2 <- glm(G1 ~ sex +
Fedu +
studytime +
failures +
schoolsup +
famsup +
goout,
data = students.math,
family = poisson())
summary(model2)
# Analysis of deviance test between Model 1 and Model 2
deviance.analysis <- anova(model2, model1, test = "Chi")
print(deviance.analysis)
# Model 3: GLM with Walc instead of goout
model3 <- glm(G1 ~ sex +
Fedu +
studytime +
failures +
schoolsup +
famsup +
Walc,
data = students.math,
family = poisson())
summary(model3)
# Goodness-of-fit: AIC value
cat("AIC value of Model 3:", AIC(model3), "\n")
install.packages("ISLR")  # This package contains the Hitters dataset
install.packages("glmnet")
library(tidyverse)
library(ggplot2)
library(ISLR)
library(glmnet)
# Loading the dataset and creating a new dataset
# containing only those players for which all data is available.
# Load the Hitters dataset
data(Hitters)
# View the first few rows of the dataset to understand its structure
head(Hitters)
# Create a new dataset containing only those players for which all data is available
HittersClean <- na.omit(Hitters)
# View the structure of the cleaned dataset to confirm there are no missing values
str(HittersClean)
?data
# Loading the dataset and creating a new dataset
# containing only those players for which all data is available.
data(Hitters)
hitters.clean <- na.omit(Hitters)
str(hitters.clean)
# Loading the dataset and creating a new dataset
# containing only those players for which all data is available.
data(Hitters)
hitters.clean <- na.omit(Hitters)
str(hitters.clean)
head(hitters.clean)
# Separate the response variable (Salary) and predictor variables (all others)
y <- hitters.clean$Salary
X <- model.matrix(Salary ~ ., data = hitters.clean)[, -1]  # Removing the intercept column
# Compute XtX
XtX <- t(X) %*% X
# Compute eigenvalues of XtX
eigenvalues <- eigen(XtX)$values
# Calculate the condition number (ratio of the largest to smallest eigenvalue)
condition.number <- max(eigenvalues) / min(eigenvalues)
condition.number
# Standardize the design matrix
X.standardized <- scale(X)
# Compute XtX for the standardized design matrix
XtX.standardized <- t(X.standardized) %*% X.standardized
# Compute eigenvalues of the standardized XtX
eigenvalues.standardized <- eigen(XtX.standardized)$values
# Calculate the condition number for the standardized design matrix
condition.number.standardized <- max(eigenvalues.standardized) / min(eigenvalues.standardized)
condition.number.standardized
